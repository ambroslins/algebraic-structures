module Algebra.Prelude
  ( module Data.Bool,
    module Data.Char,
    module Data.Either,
    module Data.Eq,
    module Data.Foldable,
    module Data.Function,
    module Data.Functor,
    module Data.Int,
    module Data.List,
    module Data.List.NonEmpty,
    module Data.Maybe,
    module Data.Ord,
    module Data.Semigroup,
    module Data.String,
    module Data.Traversable,
    module Data.Tuple,
    module Control.Applicative,
    module Control.Monad,
    Show (..),
    Read (..),
    Integer,
    Natural,
    Double,
    Float,
    Nat,
    Nat8,
    Nat16,
    Nat32,
    Nat64,
  )
where

import Control.Applicative
  ( Alternative (..),
    Applicative (..),
    Const (..),
    WrappedArrow (..),
    WrappedMonad (..),
    ZipList (..),
    liftA,
    liftA3,
    optional,
    (<$),
    (<$>),
    (<**>),
  )
import Control.Monad
  ( Functor (..),
    Monad (..),
    MonadFail (..),
    MonadPlus (..),
    ap,
    filterM,
    foldM,
    foldM_,
    forM,
    forM_,
    forever,
    guard,
    join,
    liftM,
    liftM2,
    liftM3,
    liftM4,
    liftM5,
    mapAndUnzipM,
    mapM,
    mapM_,
    mfilter,
    msum,
    replicateM,
    replicateM_,
    sequence,
    sequence_,
    unless,
    void,
    when,
    zipWithM,
    zipWithM_,
    (<$!>),
    (<=<),
    (=<<),
    (>=>),
  )
import Data.Bool
  ( Bool (..),
    bool,
    not,
    otherwise,
    (&&),
    (||),
  )
import Data.Char
  ( Char,
  )
import Data.Either
  ( Either (..),
    either,
    fromLeft,
    fromRight,
    isLeft,
    isRight,
    lefts,
    partitionEithers,
    rights,
  )
import Data.Eq (Eq (..))
import Data.Foldable
  ( Foldable (..),
    all,
    and,
    any,
    asum,
    concat,
    concatMap,
    find,
    foldlM,
    foldrM,
    forM_,
    for_,
    mapM_,
    maximumBy,
    minimumBy,
    msum,
    notElem,
    or,
    sequenceA_,
    sequence_,
    traverse_,
  )
import Data.Function
  ( const,
    fix,
    flip,
    id,
    on,
    ($),
    (&),
    (.),
  )
import Data.Functor
  ( Functor (..),
    void,
    ($>),
    (<$>),
    (<&>),
  )
import Data.Int (Int, Int16, Int32, Int64, Int8)
import Data.List
  ( break,
    cycle,
    delete,
    deleteBy,
    deleteFirstsBy,
    drop,
    dropWhile,
    dropWhileEnd,
    elem,
    elemIndex,
    elemIndices,
    filter,
    findIndex,
    findIndices,
    foldl,
    foldl',
    foldr,
    genericDrop,
    genericIndex,
    genericLength,
    genericReplicate,
    genericSplitAt,
    genericTake,
    group,
    groupBy,
    insert,
    insertBy,
    intercalate,
    intersect,
    intersectBy,
    intersperse,
    isInfixOf,
    isPrefixOf,
    isSubsequenceOf,
    isSuffixOf,
    iterate,
    iterate',
    length,
    lines,
    lookup,
    map,
    mapAccumL,
    mapAccumR,
    maximum,
    maximumBy,
    minimum,
    minimumBy,
    notElem,
    nub,
    nubBy,
    null,
    or,
    partition,
    permutations,
    repeat,
    replicate,
    reverse,
    scanl,
    scanl',
    scanr,
    sort,
    sortBy,
    sortOn,
    span,
    splitAt,
    stripPrefix,
    subsequences,
    take,
    takeWhile,
    transpose,
    uncons,
    unfoldr,
    union,
    unionBy,
    unlines,
    unwords,
    unzip,
    unzip3,
    unzip4,
    unzip5,
    unzip6,
    unzip7,
    words,
    zip,
    zip3,
    zip4,
    zip5,
    zip6,
    zip7,
    zipWith,
    zipWith3,
    zipWith4,
    zipWith5,
    zipWith6,
    zipWith7,
    (!!),
    (++),
    (\\),
  )
import Data.List.NonEmpty
  ( NonEmpty (..),
    group1,
    groupAllWith1,
    groupBy1,
    groupWith1,
    head,
    init,
    inits,
    last,
    nonEmpty,
    scanl1,
    scanr1,
    some1,
    tail,
    tails,
    (<|),
  )
import Data.Maybe
  ( Maybe (..),
    catMaybes,
    fromJust,
    fromMaybe,
    isJust,
    isNothing,
    listToMaybe,
    mapMaybe,
    maybe,
    maybeToList,
  )
import Data.Ord
  ( Down (..),
    Ord (..),
    Ordering (..),
    comparing,
  )
import Data.Semigroup (Product (..), Sum (..))
import Data.String
  ( IsString (..),
    String,
  )
import Data.Traversable
  ( Traversable (..),
    fmapDefault,
    foldMapDefault,
    for,
    forM,
    mapAccumL,
    mapAccumR,
  )
import Data.Tuple
  ( curry,
    fst,
    snd,
    swap,
    uncurry,
  )
import Data.Word
  ( Word,
    Word16,
    Word32,
    Word64,
    Word8,
  )
import GHC.Natural (Natural)
import Prelude (Double, Float, Integer, Read (..), Show (..))

type Nat = Word

type Nat8 = Word8

type Nat16 = Word16

type Nat32 = Word32

type Nat64 = Word64